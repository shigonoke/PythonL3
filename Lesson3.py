#  Лекция 3 Функции, рекурсия,алгоритмы.
# Функция — это фрагмент программы, используемый многократно:
# Alias (псевдоним) — альтернативное имя, которое даётся функции при её импорте
# из файла.
# Рекурсия — это функция, вызывающая сама себя.
# def function_name(x):# функция обозначается def
# # body line 1
# # ...
# # body line n
# # optional return
# Задание: Необходимо создать функцию sumNumbers(n), которая будет считать
# сумму всех элементов от 1 до n.


# def sum_numbers(n):# в скобках аргумент, тип данных не нужен т.к у Питона динамическая типизация
#     summa = 0 # создали переменную
#     for i in range(1, n+1):# считаем сумму от 1-го элемента до n+1
#       summa += i  # при каждой итерации цикла мы будем увеличивать сумму на i
#     print(summa)# печатаем переменную сумма
# sum_numbers(5) # вызвать сумму и в параметрах передать число


# def sum_numbers(n):# в скобках аргумент, тип данных не нужен т.к у Питона динамическая типизация
#      summa = 0 # создали переменную
#      for i in range(1, n+1):# считаем сумму от 1-го элемента до n+1
#        summa += i  # при каждой итерации цикла мы будем увеличивать сумму на i
#      return summa # будет возвращаться переменная сумма, return завершает работу функции
# print(sum_numbers(5)) # вызвать сумму и вывести результат
# Сколько аргументов функция принимает столько и передает. Если не передаем аргумент 
# нашей функции то берется значение по умолчанию если аргумент передаем то переменная будет иметь
# значение того аргумента кот-ый мы передали

# Опишем функцию кот-ая будет принимать неограниченное кол-во элементов

# Можно указать любое количество значений аргумента функции.
# Перед аргументом надо поставить *.

# def sum_str (*args):
#     res = ' '
#     for i in args:# пройдемся по всем аргументам переменной args
#         res += i# при каждой итерации мы будем к res прибавлять i
#     return res # вернем res

# print(sum_str('q', 'e', 'l'))
# print(sum_str('q', 'e', 'l', 'r', 'f'))

# Импортировать модуль 
# import modul
# print(modul.max1(5, 9))# чтобы вызвать ф-ию из другого файла мы должны импортировать этот модуль 
# обратиться к модулю и указать название функции
# можно напрямую импортировать

# from modul import max1
# print(max1(5, 9))

# from modul import * # ставим * если из модуля 1 мы хотим импортировать все ф-ии
# print(max1(5, 10))

# import modul as m1# импортировать modul как имя m1
# print(m1.max1(10, 9))# вызываем m1


# Рекурсия 
# Рекурсия — это функция, вызывающая сама себя
# При описании рекурсии важно указать, когда функции надо
# остановиться и перестать вызывать саму себя. По-другому говоря, необходимо
# указать базис рекурсии
# Задача: Пользователь вводит число n. Необходимо вывести n - первых
# членов последовательности Фибоначчи.

# def fib(n):# создадим функцию которая будет принимать одно значение n 
#     if n in [1, 2]:# укажем условие выхода: если n будет в списке [1, 2]
#         return 1 # то вернем 1(базис)
#     return fib(n - 1) + fib(n - 2)# иначе вернем рекурсию(Фибоначи каждое последующее число равно сумме
# #2-ух предыдущих)
# list_1 = []# создадим список list_1 в кот-ый будем записывать числа
# for i in range(1, 10):# идем в цикле от 1 до 10
#     list_1.append(fib(i))# при каждой итерации цикла мы в список list_1 будем добавлять вызов ф-ии
    #fib
# print(list_1) # [1, 1, 2, 3, 5, 8, 13, 21, 34]


# Алгоритмы
# Алгоритмом называется набор инструкций для выполнения некоторой задачи
# Быстрая сортировка
# “Программирование это разбиение чего-то большого и невозможного на что-то
# маленькое и вполне реальное”
# def quicksort(array):# создадим ф-ию в параметрах передаем массив
#     if len(array) <= 1:#делаем проверку если длина массива <= 1 то
#         return array#возвращаем массив
#     else:
#         pivot = array[0]
#     less = [i for i in array[1:] if i <= pivot]#в этот массив будем записывать значения <=pivot
#     greater = [i for i in array[1:] if i > pivot]#в этот массив будем записывать значения >pivot
#     return quicksort(less) + [pivot] + quicksort(greater)# вызывать рекурсию
# print(quicksort([10, 5, 2, 3]))
# 1-е повторение рекурсии:
# ○ array = [10, 5, 2, 3]
# ○ pivot = 10
# ○ less = [5, 2, 3]
# ○ greater = []
# ○ return quicksort([5, 2, 3]) + [10] + quicksort([])
# ● 2-е повторение рекурсии:
# ○ array = [5, 2, 3]
# ○ pivot = 5
# ○ less = [2, 3]
# ○ greater = []
# ○ return quicksort([2, 3]) + [5] + quicksort([]) # Важно! Не забывайте, что
# здесь помимо вызова рекурсии добавляется список [10]
# ● 3-е повторение рекурсии:
# ○ array = [2, 3]
# ○ return [2, 3] # Сработал базовый случай рекурсии
# На этом работа рекурсии завершилась и итоговый список будет выглядеть таким
# образом: [2, 3] + [5] + [10] = [2, 3, 5, 10]


#Сортировка слиянием
# def merge_sort(nums):
#     if len(nums) > 1:
#         mid = len(nums) // 2
#         left = nums[:mid]# создадим список где будем брать начало т.е левую часть
#         right = nums[mid:]#создадим список где будем брать правую часть
#         merge_sort(left)
#         merge_sort(right)# строка 120-124 делим список на 2 пока не осталось по одному элементу
#         i = j = k = 0
#         while i < len(left) and j < len(right):
#             if left[i] < right[j]:
#                 nums[k] = left[i]
#                 i += 1
#             else:
#                 nums[k] = right[j]
#                 j += 1
#                 k += 1
#         while i < len(left):
#             nums[k] = left[i]
#             i += 1
#             k += 1
#         while j < len(right):
#             nums[k] = right[j]
#             j += 1
#             k += 1
# list1 = [38, 27, 43, 3, 9, 82, 10]
# merge_sort(list1)
# print(list1)
